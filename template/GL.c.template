/*******************************************************************************
 * This file was generated by GLBrebis on <%=now%>
 * https://github.com/mchiasson/GLBrebis
 *******************************************************************************
 * GLBrebis License (MIT)
 *******************************************************************************
 * Copyright (c) <%=year%> Mathieu-Andr√© Chiasson
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be included in
 *    all copies or substantial portions of the Software.
 *
 * Disclaimer:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ******************************************************************************/

#define <%=PREFIX%>_PROTO_IMPL 0
#include <<%=includePrefix%><%=Prefix%>GL.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if __EMSCRIPTEN__
    extern void* emscripten_GetProcAddress(const char *name_);
#elif defined(_WIN32) && !defined(__CYGWIN__)
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN 1
    #endif
    #include <windows.h>
    static HMODULE s_<%=prefix%>GLLib = NULL;
    #ifndef <%=PREFIX%>_GL_LIBRARY
        #define <%=PREFIX%>_GL_LIBRARY "opengl32.dll"
    #endif
#else
    #include <dlfcn.h>
#endif

#ifndef <%=PREFIX%>_SSCANF
    #if defined(_MSC_VER)
        #define <%=PREFIX%>_SSCANF sscanf_s
    #else
        #define <%=PREFIX%>_SSCANF sscanf
    #endif
#endif

<%=Prefix%>GLConfig <%=prefix%>GL = {0};

typedef void(<%=PREFIX%>_STD_CALL *<%=Prefix%>GLProc)();

<%=PREFIX%>_FORCE_INLINE <%=Prefix%>GLProc <%=prefix%>GLGetProcAddress(const char *procName)
{
    <%=Prefix%>GLProc proc;
#if __EMSCRIPTEN__
    proc = (<%=Prefix%>GLProc)emscripten_GetProcAddress(procName);
#elif defined(_WIN32)
    proc = (<%=Prefix%>GLProc)wglGetProcAddress(procName);
    if (!proc)
    {
        proc = (<%=Prefix%>GLProc)GetProcAddress(s_<%=prefix%>GLLib, procName);
    }
#else
    *(void **)(&proc) = dlsym(NULL, procName);
#endif
    return proc;
}

static void <%=prefix%>GLAddExtension(bool isGLES, const char* const extensionStr, size_t extensionStrLength) {
    if(isGLES) {
<%=glesAddExtensionBlock%>
        // Discovered a bug in Qualcomm Adreno 200 OpenGL ES driver, where
        // these three extensions are literally fused together.
        else if ((extensionStrLength == 54) && strncmp(extensionStr, "GL_EXT_debug_labelGL_EXT_debug_markerGL_EXT_robustness", extensionStrLength) == 0) {
                <%=prefix%>GL.support[GL_EXT_debug_label] = true;
                <%=prefix%>GL.support[GL_EXT_debug_marker] = true;
                <%=prefix%>GL.support[GL_EXT_robustness] = true;
        }
    } else {
<%=glAddExtensionBlock%>
    }
#if !defined(NDEBUG)
    fprintf(stderr, "Found unwrangled extension: %.*s\n", (int)extensionStrLength, extensionStr);
#endif
}

bool <%=prefix%>GLInit() {
    bool        isGLES = false;
    const char* version = NULL;
    int32_t     versionMajor = -1;
    int32_t     versionMinor = -1;

#if defined(_WIN32)
    if (s_<%=prefix%>GLLib == NULL)
    {
        s_<%=prefix%>GLLib = LoadLibraryA(TEXT(<%=PREFIX%>_GL_LIBRARY));
    }
#endif

<%=getProcBlock%>
    if (!<%=prefix%>GL.GetError) {
        fprintf(stderr, "Could not find 'glGetError'\n");
        return false;
    }

    if (!<%=prefix%>GL.GetString) {
        fprintf(stderr, "Could not find 'glGetString'\n");
        return false;
    }

    version  = (const char*)<%=prefix%>GL.GetString(GL_VERSION);

    if(!version) {
        fprintf(stderr, "Missing GL context. Make sure your context is created and made current prior to calling <%=prefix%>GLInit.\n");
        return false;
    }

    if ((<%=PREFIX%>_SSCANF(version, "OpenGL ES %d.%d",    &versionMajor, &versionMinor) == 2) ||
        (<%=PREFIX%>_SSCANF(version, "OpenGL ES-CM %d.%d", &versionMajor, &versionMinor) == 2)) {
        isGLES = true;
    } else if (<%=PREFIX%>_SSCANF(version, "%d.%d", &versionMajor, &versionMinor) != 2) {
        fprintf(stderr, "Could not determine OpenGL/OpenGLES version.\n");
        return false;
    }

    if(isGLES) {
<%=glesSupportBlock%>
    } else {
<%=glSupportBlock%>
    }

    if (<%=prefix%>GL.support[GL_VERSION_3_0] || <%=prefix%>GL.support[GL_ES_VERSION_3_0]) {
        int32_t i = 0;
        int32_t nExtensionsCount = 0;
        <%=prefix%>GL.GetIntegerv(GL_NUM_EXTENSIONS, &nExtensionsCount);
        while(i < nExtensionsCount)
        {
            const char* extensionStr = (const char*)<%=prefix%>GL.GetStringi(GL_EXTENSIONS, i++);
            <%=prefix%>GLAddExtension(isGLES, extensionStr, strlen(extensionStr));
        }
    } else {
        const char* extensionsStr = (const char*)<%=prefix%>GL.GetString(GL_EXTENSIONS);
        while (extensionsStr) {
            const char* spacerPos = strchr(extensionsStr, ' ');
            size_t extensionsStrLength = spacerPos ? (size_t)(spacerPos++ - extensionsStr) : strlen(extensionsStr);
            <%=prefix%>GLAddExtension(isGLES, extensionsStr, extensionsStrLength);
            extensionsStr = spacerPos;
        }
    }

    return true;
}

void <%=prefix%>GLShutdown() {
    memset(&<%=prefix%>GL, 0, sizeof(<%=Prefix%>GLConfig));

#if defined(_WIN32)
    if (s_<%=prefix%>GLLib)
    {
        FreeLibrary(s_<%=prefix%>GLLib);
        s_<%=prefix%>GLLib = NULL;
    }
#endif
}

void _<%=prefix%>GLCheckError(const char* fileName, int lineNumber) {
    GLenum eErrorID = <%=prefix%>GL.GetError();
    if (eErrorID != GL_NO_ERROR) {
        do {
            static const char* errMsg[] = {
                "GL_INVALID_ENUM: An unacceptable value is specified for an enumerated argument.",
                "GL_INVALID_VALUE: A numeric argument is out of range.",
                "GL_INVALID_OPERATION: The specified operation is not allowed in the current state.",
                "GL_STACK_OVERFLOW: This function caused a stack overflow.",
                "GL_STACK_UNDERFLOW: This function would cause a stack underflow.",
                "GL_OUT_OF_MEMORY: There is not enough memory left to execute the command.",
                "GL_INVALID_FRAMEBUFFER_OPERATION: The command is trying to render to or read from the framebuffer while the currently bound framebuffer is not framebuffer complete.",
                "GL_CONTEXT_LOST: The context has been lost, due to a graphics card reset."
            };

            size_t uErrorIndex = eErrorID - GL_INVALID_ENUM;
            if (uErrorIndex > sizeof(errMsg)) {
                fprintf(stderr, "file %s, line %d : Unknown error 0x%X\n", fileName, lineNumber, eErrorID);
            } else {
                fprintf(stderr, "file %s, line %d : %s\n", fileName, lineNumber, errMsg[uErrorIndex]);
            }
        } while((eErrorID = <%=prefix%>GL.GetError()) != GL_NO_ERROR);
    }
}
