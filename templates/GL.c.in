/*******************************************************************************
 * This file was generated by GLBrebis on <%=now%>
 * https://github.com/mchiasson/GLBrebis
 *
 * The content of this file is the result of parsing the following headers:
 * https://www.khronos.org/registry/gles/api/GLES3/gl32.h
 * https://www.khronos.org/registry/gles/api/GLES2/gl2ext.h
 * https://www.opengl.org/registry/api/GL/glcorearb.h
 * https://www.opengl.org/registry/api/GL/glext.h
 *******************************************************************************
 * GLBrebis License (MIT)
 *******************************************************************************
 * Copyright (c) <%=year%> Mathieu-Andr√© Chiasson
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *******************************************************************************
 * GLES3/gl32.h, GLES2/gl2ext.h, GL/glcorearb.h, GL/glext.h License
 *******************************************************************************
** Copyright (c) 2013-2017 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*******************************************************************************/

#include <%='<'%><%=includePrefix%><%=Prefix%>GL.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(_WIN32) && !defined(__CYGWIN__)
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN 1
    #endif
    #include <windows.h>
#else
    #include <dlfcn.h>
#endif

static const char* const s_<%=prefix%>GLExtensionsStr[<%=result.getAllUniqueVersionGroups().size() + result.getAllUniqueExtensionGroups().size() + 1%>] = {
    "UNKNOWN"<%
    for (group in result.getAllUniqueVersionGroups()) {
        out.print(",\n    \"" + group.name + "\"")
    }
    for (group in result.getAllUniqueExtensionGroups()) {
        out.print(",\n    \"" + group.name + "\"")
    }%>
};

<%=Prefix%>GLAPIConfig <%=prefix%>GLAPI = {0};

static inline <%=prefix%>GLProc <%=prefix%>GLGetProcAddress(const char* procName){
    <%=prefix%>GLProc proc;
#if defined(_WIN32)
    *(void**) (&proc) = wglGetProcAddress(procName);
#else
    *(void**) (&proc) = dlsym(NULL, procName);
#endif
    return proc;
}

static void <%=prefix%>GLAddExtension(const char* const extensionStr, size_t extensionStrLength) {
    while (extensionStr && extensionStrLength > 0) {
        if(<%=prefix%>GLAPI.bIsGLES) {
            <%for (extension in result.getAllUniqueGLESExtensionGroups()) {%>
            if (strncmp(extensionStr, s_<%=prefix%>GLExtensionsStr[<%=extension.name%>], extensionStrLength) == 0) {
                if (!<%=prefix%>GLAPI.supportedExtensions[<%=extension.name%>]) {
                    <%=prefix%>GLAPI.supportedExtensions[<%=extension.name%>] = true;
                    <%=prefix%>GLAPI.extensions[<%=prefix%>GLAPI.extensionsCount++] = s_<%=prefix%>GLExtensionsStr[<%=extension.name%>];
                }
                break;
            }<%}%>
            if (strncmp(extensionStr, "GL_EXT_debug_labelGL_EXT_debug_markerGL_EXT_robustness", extensionStrLength) == 0) { /* Silly Qualcomm Adreno 200 OpenGL ES driver bug */
                <%=prefix%>GLAddExtension(s_<%=prefix%>GLExtensionsStr[GL_EXT_debug_label], strlen(s_<%=prefix%>GLExtensionsStr[GL_EXT_debug_label]));
                <%=prefix%>GLAddExtension(s_<%=prefix%>GLExtensionsStr[GL_EXT_debug_marker], strlen(s_<%=prefix%>GLExtensionsStr[GL_EXT_debug_marker]));
                <%=prefix%>GLAddExtension(s_<%=prefix%>GLExtensionsStr[GL_EXT_robustness], strlen(s_<%=prefix%>GLExtensionsStr[GL_EXT_robustness]));
                break;
            }
        } else {
            <%for (extension in result.getAllUniqueGLExtensionGroups()) {%>
            if (strncmp(extensionStr, s_<%=prefix%>GLExtensionsStr[<%=extension.name%>], extensionStrLength) == 0) {
                if (!<%=prefix%>GLAPI.supportedExtensions[<%=extension.name%>]) {
                    <%=prefix%>GLAPI.supportedExtensions[<%=extension.name%>] = true;
                    <%=prefix%>GLAPI.extensions[<%=prefix%>GLAPI.extensionsCount++] = s_<%=prefix%>GLExtensionsStr[<%=extension.name%>];
                }
                break;
            }<%}%>
        }
        fprintf(stderr, "Found unwrangled extension: %.*s\\n", (int)extensionStrLength, extensionStr);
        break;
    }
}

bool <%=prefix%>GLInit(){
#if <%=PREFIX%>_WRANGLER_ENABLED
    /* Version procedures */
    <%for (function in result.getAllUniqueVersionFunctions()) {%>
    <%=prefix%>GLAPI.<%=prefix%>Gl<%=function.name.substring(2)%>Proc = <%=prefix%>GLGetProcAddress("<%=function.name%>");<%}%>

    /* Extension procedures */
    <%for (function in result.getAllUniqueExtensionFunctions()) {%>
    <%=prefix%>GLAPI.<%=prefix%>Gl<%=function.name.substring(2)%>Proc = <%=prefix%>GLGetProcAddress("<%=function.name%>");<%}%>

    if (!<%=prefix%>GLAPI.<%=prefix%>GlGetErrorProc){
        fprintf(stderr, "Could not find 'glGetError'\\n");
        return false;
    }

    if (!<%=prefix%>GLAPI.<%=prefix%>GlGetStringProc){
        fprintf(stderr, "Could not find 'glGetString'\\n");
        return false;
    }
#endif

    /* If GL_ES_VERSION_2_0 or GL_VERSION_1_0 are set to false, this is for sure our first detecting our GL capabilities */
    if (!<%=prefix%>GLAPI.supportedExtensions[GL_ES_VERSION_2_0] || !<%=prefix%>GLAPI.supportedExtensions[GL_VERSION_1_0]) {
        <%=prefix%>GLAPI.pVersion  = (const char*)<%=prefix%>GLCheckError(glGetString(GL_VERSION));
        <%=prefix%>GLAPI.pVendor   = (const char*)<%=prefix%>GLCheckError(glGetString(GL_VENDOR));
        <%=prefix%>GLAPI.pRenderer = (const char*)<%=prefix%>GLCheckError(glGetString(GL_RENDERER));

        if(!<%=prefix%>GLAPI.pVersion) {
            fprintf(stderr, "Missing GL context. Make sure your context is created and made current prior to calling <%=prefix%>GLInit.\\n");
            return false;
        }

        if ((sscanf(<%=prefix%>GLAPI.pVersion, "OpenGL ES %d.%d",    &<%=prefix%>GLAPI.nVersionMajor, &<%=prefix%>GLAPI.nVersionMinor) == 2) ||
            (sscanf(<%=prefix%>GLAPI.pVersion, "OpenGL ES-CM %d.%d", &<%=prefix%>GLAPI.nVersionMajor, &<%=prefix%>GLAPI.nVersionMinor) == 2)) {
            <%=prefix%>GLAPI.bIsGLES = true;
        } else if (sscanf(<%=prefix%>GLAPI.pVersion, "%d.%d", &<%=prefix%>GLAPI.nVersionMajor, &<%=prefix%>GLAPI.nVersionMinor) != 2) {
            fprintf(stderr, "Could not determine OpenGL/OpenGLES version.\\n");
            return false;
        }
        <%def versionPattern = java.util.regex.Pattern.compile(".*_([0-9]+)_([0-9]+)", 0)%>
        if(<%=prefix%>GLAPI.bIsGLES) {
            <%
            for (version in result.getAllUniqueGLESVersionGroups()) {
                def versionMatcher = versionPattern.matcher(version.name)
                if (versionMatcher.find()) {
                    String major = versionMatcher.group(1)
                    String minor = versionMatcher.group(2)
            %><%=prefix%>GLAPI.supportedExtensions[<%=version.name%>] = ((<%=prefix%>GLAPI.nVersionMajor > <%=major%>) || ((<%=prefix%>GLAPI.nVersionMajor == <%=major%>) && (<%=prefix%>GLAPI.nVersionMinor >= <%=minor%>)));<%
                }
            }
            %>
        } else {
            <%
            for (version in result.getAllUniqueGLVersionGroups()) {
                def versionMatcher = versionPattern.matcher(version.name)
                if (versionMatcher.find())
                {
                    String major = versionMatcher.group(1)
                    String minor = versionMatcher.group(2)
            %><%=prefix%>GLAPI.supportedExtensions[<%=version.name%>] = ((<%=prefix%>GLAPI.nVersionMajor > <%=major%>) || ((<%=prefix%>GLAPI.nVersionMajor == <%=major%>) && (<%=prefix%>GLAPI.nVersionMinor >= <%=minor%>)));<%
                }
            }
            %>
        }

        <%=prefix%>GLAPI.pShadingLanguageVersion = (const char*)<%=prefix%>GLCheckErrorDebug(glGetString(GL_SHADING_LANGUAGE_VERSION));
        if (sscanf(<%=prefix%>GLAPI.pShadingLanguageVersion, "%d", &<%=prefix%>GLAPI.nShadingLanguageVersionMajor) == 1) {
            <%=prefix%>GLAPI.nShadingLanguageVersionMinor = (<%=prefix%>GLAPI.nShadingLanguageVersionMajor % 100);
            <%=prefix%>GLAPI.nShadingLanguageVersionMajor = <%=prefix%>GLAPI.nShadingLanguageVersionMajor / 100;
        }
        else if (sscanf(<%=prefix%>GLAPI.pShadingLanguageVersion, "OpenGL ES GLSL ES %d.%d", &<%=prefix%>GLAPI.nShadingLanguageVersionMajor, &<%=prefix%>GLAPI.nShadingLanguageVersionMinor) != 2) {
            fprintf(stderr, "Could not parse shading language version from string : '%s'. Defaulting to Shading language version 1.0.\\n", <%=prefix%>GLAPI.pShadingLanguageVersion);
            <%=prefix%>GLAPI.nShadingLanguageVersionMajor = 1;
            <%=prefix%>GLAPI.nShadingLanguageVersionMinor = 0;
        }

#if !(<%=PREFIX%>_WRANGLER_ENABLED)
        if (<%=prefix%>GLAPI.supportedExtensions[GL_VERSION_3_0] || <%=prefix%>GLAPI.supportedExtensions[GL_ES_VERSION_3_0]) {
            int32_t i = 0;
            int32_t nExtensionsCount = 0;
            <%=prefix%>GLCheckErrorDebug(glGetIntegerv(GL_NUM_EXTENSIONS, &nExtensionsCount));
            while(i < nExtensionsCount)
            {
                const char* extensionStr = (const char*)<%=prefix%>GLCheckErrorDebug(glGetStringi(GL_EXTENSIONS, i++));
                <%=prefix%>GLAddExtension(extensionStr, strlen(extensionStr));
            }
        } else
#endif
        {
            const char* extensionsStr = (const char*)<%=prefix%>GLCheckErrorDebug(glGetString(GL_EXTENSIONS));
            while (extensionsStr) {
                const char* spacerPos = strchr(extensionsStr, ' ');
                size_t extensionsStrLength = spacerPos ? (size_t)(spacerPos++ - extensionsStr) : strlen(extensionsStr);
                <%=prefix%>GLAddExtension(extensionsStr, extensionsStrLength);
                extensionsStr = spacerPos;
            }
        }
    }
    return true;
}

void <%=prefix%>GLShutdown() {
    memset(&<%=prefix%>GLAPI, 0, sizeof(<%=Prefix%>GLAPIConfig));
}

void _<%=prefix%>GLCheckError(const char* fileName, int lineNumber, const char* functionName) {
    GLenum eErrorID = glGetError();
    if (eErrorID != GL_NO_ERROR) {
        do {
            static const char* errMsg[] = {
                "GL_INVALID_ENUM: An unacceptable value is specified for an enumerated argument.",
                "GL_INVALID_VALUE: A numeric argument is out of range.",
                "GL_INVALID_OPERATION: The specified operation is not allowed in the current state.",
                "GL_STACK_OVERFLOW: This function caused a stack overflow.",
                "GL_STACK_UNDERFLOW: This function would cause a stack underflow.",
                "GL_OUT_OF_MEMORY: There is not enough memory left to execute the command.",
                "GL_INVALID_FRAMEBUFFER_OPERATION: The command is trying to render to or read from the framebuffer while the currently bound framebuffer is not framebuffer complete.",
                "GL_CONTEXT_LOST: The context has been lost, due to a graphics card reset."
            };

            size_t uErrorIndex = eErrorID - GL_INVALID_ENUM;
            if (uErrorIndex > sizeof(errMsg)) {
                fprintf(stderr, "file %s, line %d, function %s : Unknown error 0x%X\\n", fileName, lineNumber, functionName, eErrorID);
            } else {
                fprintf(stderr, "file %s, line %d, function %s : %s\\n", fileName, lineNumber, functionName, errMsg[uErrorIndex]);
            }
        } while((eErrorID = glGetError()) != GL_NO_ERROR);
    }
}
